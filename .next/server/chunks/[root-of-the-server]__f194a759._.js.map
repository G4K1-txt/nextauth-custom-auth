{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Projeto/fine/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from \"next-auth\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"Credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"text\" },\r\n        senha: { label: \"Senha\", type: \"password\" }\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.senha) {\r\n          throw new Error(\"Por favor, forneça e-mail e senha.\");\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { email: credentials.email },\r\n        });\r\n\r\n        if (!user) {\r\n          throw new Error(\"E-mail ou senha inválidos.\");\r\n        }\r\n\r\n        const isPasswordValid = await bcrypt.compare(credentials.senha, user.senha);\r\n        if (!isPasswordValid) {\r\n          throw new Error(\"E-mail ou senha inválidos.\");\r\n        }\r\n\r\n        if (!user.emailVerificado) {\r\n          throw new Error(\"Seu e-mail ainda não foi verificado. Por favor, verifique sua caixa de entrada.\");\r\n        }\r\n\r\n        return {\r\n          id: user.id.toString(),\r\n          email: user.email,\r\n          name: user.nome,\r\n        };\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.email = user.email;\r\n        token.name = user.name;\r\n      }\r\n      return token;\r\n    },\r\nasync session({ session, token }) {\r\n  if (token) {\r\n    session.user = {\r\n      id: token.id as string,\r\n      email: token.email as string,\r\n      name: token.name as string,\r\n    };\r\n  }\r\n  return session;\r\n}\r\n\r\n  },\r\n  pages: {\r\n    signIn: '/login',\r\n    error: '/login',\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n};\r\n\r\n// 2. Passe as 'authOptions' para o NextAuth e exporte o handler\r\nconst handler = NextAuth(authOptions);\r\n\r\n// 3. Exporte os métodos GET e POST do handler para o Next.js reconhecer a rota de API\r\nexport { handler as GET, handler as POST };"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAGxB,MAAM,cAA+B;IAC1C,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAW;YAC5C;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,OAAO;oBAC9C,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBAEA,IAAI,CAAC,MAAM;oBACT,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,kBAAkB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAAC,YAAY,KAAK,EAAE,KAAK,KAAK;gBAC1E,IAAI,CAAC,iBAAiB;oBACpB,MAAM,IAAI,MAAM;gBAClB;gBAEA,IAAI,CAAC,KAAK,eAAe,EAAE;oBACzB,MAAM,IAAI,MAAM;gBAClB;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,KAAK,GAAG,KAAK,KAAK;gBACxB,MAAM,IAAI,GAAG,KAAK,IAAI;YACxB;YACA,OAAO;QACT;QACJ,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO;gBACT,QAAQ,IAAI,GAAG;oBACb,IAAI,MAAM,EAAE;oBACZ,OAAO,MAAM,KAAK;oBAClB,MAAM,MAAM,IAAI;gBAClB;YACF;YACA,OAAO;QACT;IAEE;IACA,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;AAEA,gEAAgE;AAChE,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE","debugId":null}}]
}